const {
  AttributionNumero,
  Client,
  Service,
  TypeUtilisation,
  NumeroAttribue,
  Pnn
} = require("../../models");
const { Op } = require("sequelize");

class AttributionNumeroController {
  // üìå Cr√©er une attribution
  static async createAttribution(req, res) {
    try {
      const {
        type_utilisation_id,
        service_id,
        pnn_id,
        client_id,
        duree_utilisation,
        numero_attribue, // Tableau des num√©ros attribu√©s
        reference_decision,
        etat_autorisation,
        utilisation_id
      } = req.body;

      // Validation : v√©rifier que le tableau des num√©ros attribu√©s est fourni
      if (
        !numero_attribue ||
        !Array.isArray(numero_attribue) ||
        numero_attribue.length === 0
      ) {
        return res.status(400).json({
          success: false,
          message:
            "Le tableau des num√©ros attribu√©s est requis et doit √™tre un tableau non vide"
        });
      }

      if (!utilisation_id) {
        return res.status(400).json({
          success: false,
          message: "L'attribution du service attribu√© est requise"
        });
      }

      // V√©rifier si le PNN existe
      const pnn = await Pnn.findOne({ where: { id: pnn_id } });
      if (!pnn) {
        return res
          .status(404)
          .json({ success: false, message: "PNN introuvable" });
      }

      // V√©rifier que chaque num√©ro est dans la plage autoris√©e
      for (const numero of numero_attribue) {
        if (numero < pnn.bloc_min || numero > pnn.block_max) {
          return res.status(400).json({
            success: false,
            message: `Le num√©ro ${numero} est en dehors de la plage autoris√©e`
          });
        }
      }

      // V√©rifier si l'un des num√©ros existe d√©j√† dans NumeroAttribue
      const existingNumbers = await NumeroAttribue.findAll({
        where: {
          numero_attribue: {
            [Op.in]: numero_attribue // Chercher tous les num√©ros dans le tableau
          }
        }
      });

      if (existingNumbers.length > 0) {
        const alreadyAssignedNumbers = existingNumbers.map(
          (num) => num.numero_attribue
        );
        return res.status(409).json({
          success: false,
          message: `Les num√©ros suivants sont d√©j√† attribu√©s: ${alreadyAssignedNumbers.join(
            ", "
          )}`
        });
      }

      // Calcul de la date d'expiration
      const dateExpiration = new Date();
      dateExpiration.setFullYear(
        dateExpiration.getFullYear() + parseInt(duree_utilisation, 10)
      );

      // Cr√©er une seule attribution (si ce n'est pas d√©j√† fait) pour tous les num√©ros
      const attribution = await AttributionNumero.create({
        type_utilisation_id,
        service_id,
        pnn_id,
        client_id,
        duree_utilisation,
        reference_decision,
        date_expiration: dateExpiration, // Date calcul√©e
        etat_autorisation,
        utilisation_id
      });

      // Lier chaque num√©ro √† cette attribution dans la table NumeroAttribue
      const numeroAttribueEntries = numero_attribue.map((numero) => ({
        attribution_id: attribution.id,
        numero_attribue: numero,
        created_at: new Date(),
        updated_at: new Date()
      }));

      // Ins√©rer tous les num√©ros dans la table NumeroAttribue
      await NumeroAttribue.bulkCreate(numeroAttribueEntries);

      return res.status(201).json({
        success: true,
        message: "Attribution et num√©ros cr√©√©s avec succ√®s",
        attribution
      });
    } catch (error) {
      console.error(error);
      return res
        .status(500)
        .json({ success: false, message: "Erreur interne du serveur" });
    }
  }

  // üìå R√©cup√©rer toutes les attributions
  static async getAllAttributions(req, res) {
    try {
      const attributions = await AttributionNumero.findAll({
        include: [
          { model: Client },
          { model: Service },
          { model: TypeUtilisation },
          { model: Pnn },
          { model: NumeroAttribue }
        ]
      });

      return res.status(200).json(attributions);
    } catch (error) {
      console.error(error);
      return res.status(500).json({ message: "Erreur interne du serveur" });
    }
  }

  // üìå R√©cup√©rer une attribution par ID
  static async getAttributionById(req, res) {
    try {
      const { id } = req.params;
      const attribution = await AttributionNumero.findByPk(id, {
        include: [
          { model: Client, attributes: ["denomination"] },
          { model: Service, attributes: ["nom_service"] },
          { model: TypeUtilisation, attributes: ["libele_type"] },
          { model: Pnn, attributes: ["partition_prefix"] },
          { model: NumeroAttribue, attributes: ["numero_attribue"] }
        ]
      });

      if (!attribution) {
        return res.status(404).json({ message: "Attribution non trouv√©e" });
      }

      return res.status(200).json(attribution);
    } catch (error) {
      console.error(error);
      return res.status(500).json({ message: "Erreur interne du serveur" });
    }
  }

  // üìå Mettre √† jour une attribution
  static async updateAttribution(req, res) {
    try {
      const { id } = req.params;
      const {
        type_utilisation_id,
        service_id,
        pnn_id,
        client_id,
        duree_utilisation,
        numero_attribue,
        reference_decision,
        etat_autorisation
      } = req.body;

      // V√©rifier si l'attribution existe
      const attribution = await AttributionNumero.findByPk(id);
      if (!attribution) {
        return res.status(404).json({ message: "Attribution non trouv√©e" });
      }

      // Mise √† jour des champs
      attribution.type_utilisation_id = type_utilisation_id;
      attribution.service_id = service_id;
      attribution.pnn_id = pnn_id;
      attribution.client_id = client_id;
      attribution.duree_utilisation = duree_utilisation;
      attribution.numero_attribue = numero_attribue;
      attribution.reference_decision = reference_decision;
      attribution.etat_autorisation = etat_autorisation;

      // Recalcul de la date d'expiration si une nouvelle dur√©e est fournie
      if (duree_utilisation) {
        const dateExpiration = new Date();
        dateExpiration.setFullYear(
          dateExpiration.getFullYear() + parseInt(duree_utilisation, 10)
        );
        attribution.date_expiration = dateExpiration;
      }

      await attribution.save();

      return res.status(200).json({
        success: true,
        message: "Attribution mise √† jour avec succ√®s",
        attribution
      });
    } catch (error) {
      console.error(error);
      return res.status(500).json({ message: "Erreur interne du serveur" });
    }
  }

  // üìå Supprimer une attribution
  static async deleteAttribution(req, res) {
    try {
      const { id } = req.params;

      const attribution = await AttributionNumero.findByPk(id);
      if (!attribution) {
        return res.status(404).json({ message: "Attribution non trouv√©e" });
      }

      await attribution.destroy();
      return res
        .status(200)
        .json({ message: "Attribution supprim√©e avec succ√®s" });
    } catch (error) {
      console.error(error);
      return res.status(500).json({ message: "Erreur interne du serveur" });
    }
  }

  // üìå R√©cup√©rer tous les num√©ros attribu√©s pour un PNN
  static async getAssignedNumbersByPnn(req, res) {
    try {
      const { pnn_id } = req.params;

      if (!pnn_id) {
        return res.status(400).json({ error: "PNN ID est requis." });
      }

      // Recherche des attributions pour ce PNN avec √©tat autorisation true
      const attributions = await AttributionNumero.findAll({
        where: {
          pnn_id,
          etat_autorisation: true // Filtrer uniquement les attributions autoris√©es
        },
        attributes: ["id"] // On r√©cup√®re l'id de l'attribution
      });

      // V√©rifier si des attributions ont √©t√© trouv√©es
      if (!attributions || attributions.length === 0) {
        return res.status(200).json([]); // Retourne un tableau vide si aucune attribution trouv√©e
      }

      // Extraire les IDs des attributions pour la requ√™te suivante
      const attributionIds = attributions.map((attribution) => attribution.id);

      // Rechercher les num√©ros attribu√©s dans la table NumeroAttribues
      const assignedNumbers = await NumeroAttribue.findAll({
        where: {
          attribution_id: {
            [Op.in]: attributionIds // Rechercher les num√©ros attribu√©s pour ces attributions
          }
        },
        attributes: ["numero_attribue"] // On r√©cup√®re seulement les num√©ros attribu√©s
      });

      // V√©rifier si des num√©ros ont √©t√© trouv√©s
      if (!assignedNumbers || assignedNumbers.length === 0) {
        return res.status(200).json([]); // Retourner un tableau vide si aucun num√©ro attribu√©
      }

      // Retourner les num√©ros attribu√©s
      return res.status(200).json(assignedNumbers);
    } catch (error) {
      console.error(
        "Erreur lors de la r√©cup√©ration des num√©ros attribu√©s :",
        error
      );
      return res.status(500).json({ error: "Erreur interne du serveur." });
    }
  }

  // üìå R√©cup√©rer toutes les attributions d'un client par son ID
  static async getAttributionByClientId(req, res) {
    try {
      const { client_id } = req.params;

      if (!client_id) {
        return res.json({ success: false, message: "Client ID est requis" });
      }

      const attributions = await AttributionNumero.findAll({
        where: { client_id },
        include: [
          { model: Service },
          { model: TypeUtilisation },
          { model: Pnn },          
          { model: NumeroAttribue}
        ]
      });

      if (!attributions || attributions.length === 0) {
        return res.json({
          success: false,
          message: "Aucune attribution trouv√©e pour ce client"
        });
      }

      return res.json({ success: true, attributions });
    } catch (error) {
      console.error(error);
      return res.json({ success: false, message: "Erreur interne du serveur" });
    }
  }
}

module.exports = AttributionNumeroController;
